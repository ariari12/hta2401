package javaz.oop;

public class Basic {
/* 클래스 정의   [  ] -> 생략 가능한 항목
 * [접근제어자] [클래스 종류] class 클래스이름 [extends 부모클래스이름] [implements 인터페이스 이름] {
 * public    abstract
 * package   final
 * ┕> 접근제어자 생략 시 해당됨
 * 
 * 		// 클래스 초기화 블럭
 *		// 인스턴스 초기화 블럭
 * 		// 필드    - 속성
 * 		// 생성자
 *		// 메서드   - 기능
 *		// 내부클래스
 * }
 * 
 * 
 * 큻래스 초기화 블럭 ------------------------------
 * static {
 * 		// 클래스 변수의 초기화에 사용
 * 		// 클래스가 로딩될 때 실행 
 * }
 * 
 * 
 * 인스턴스 초기화 블럭 -----------------------------
 * {
 * 		// 인스턴스가 생성되기 전에 실행
 * 		// 생성자에서 공통적으로 수행되는 작업에 사용
 * }
 * 
 * 
 * 
 * 필드 정의 ------------------------------------
 * [접근제어자] [필드 종류] 데이터타입 필드명 [= 초기값];
 * public     final    - 상수
 * package    static   - 공유
 * protected  transient
 * private
 * 
 * 
 * 
 * 생성자 정의 ------------------------------------
 * [접근제어자] 생성자이름([매개변수타입 변수명,...]) {
 * public    클래스이름
 * package
 * protected
 * private 
 * }
 * - 객체 생성 시 단 한번만 호출되는 특수한 형태의 메서드
 * - 메모리 할당 및 객체 필드 값 초기화
 * - new 연산자로 호출
 *   - 생성자 내부에서는 this(), super()로 호출
 * 
 * - 클래스이름과 동일
 * - return 타입 선언 X
 * - 접근제어자는 보통 public
 *   singleton pattern일 때는 private으로 선언
 * - 오버로딩 가능
 * - 필수 X
 * - 상속 X
 * 
 * - 기본생성자(default constructor)
 *   - 매개변수가 없음
 *   - 생성자를 정의하지 않은 경우에 컴파일러가 자동으로 추가
 *     > 이 때 부모 클래스의 기본생성자인 super()가 자동 호출됨
 * 
 * 
 * 메서드 정의 -----------------------------------
 * [접근제어자] [메서드종류] 반환타입 메서드명([매개변수타입 변수명, ..]) [throws 예외이름] {
 * public     final    x: void
 * package    static   o: 기본타입/배열/참조자료형 	
 * protected  abstract
 * private    synchronized
 * 
 * 		[return 반환값|변수;]
 * }
 * 
*/

/* 상속 -----------------------------------
 * - 클래스의 재사용
 *   - 기존 클래스(부모)를 재사용하여 새로운 클래스(자식) 정의
 *   - 코드의 중복 작성을 줄이고 프로그램의 확장성 향상
 * - 기존 클래스 확장 or 특화
 * - is a 관계([자식]은 [부모]이다)
 * 
 * 클래스의 상속
 * - 부모 클래스(super class)와 자식 클래스 사이의 관계
 * - 부모 클래스의 필드와 메서드를 자식 클래스에서 상속 받음
 * - 단일 클래스 상속만 가능
 * - 생성자 상속 X
 *   - 하위 클래스의 객체가 생성될 때
 *     상위 클래스의 생성자(super())가 자동으로 호출됨
 *     - 상위 클래스의 데이터 필드 초기화
 *     - 명시적으로 호출하는 경우 생성자의 첫번째 줄에서 사용
 * - 자식 클래스에서 부모 클래스의 메서드 오버라이딩 가능
 *   - 반환타입, 이름, 매개변수 일치
 *   - 접근제어자는 일치하거나 접근 범위가 넓어져야 함
 *   - 구현부를 재정의
 *     - 부모 클래스에서 상속받은 메서드를 자식 클래스에서 재정의
 *     - 부모와 자식 클래스에서 같은 이름의 메서드가 다른 기능 수행
 *     - final로 선언된 메서드는 재정의 X
 *     - 부모의 클래스의 메서드에 접근할 때는 super 키워드를 이용 
 *     
 * - 상속 불가 클래스는 선언 시 final 명시
 * - 자바의 최상위 클래스는 java.lang.Object는 묵시적으로 자동 상속
 * 
 * - 클래스 선언 시 extends 키워드로 상속받을 클래스 명시
 * 
*/
	
/* 다형성(polymorphism) -----------------------------------
 * - 하나의 객체가 여러가지 형태를 가지는 것
 * - 인스턴스의 취급이 변수의 형태에 의해 바뀜
 *   - 상속 관계에서만 형변환 가능
 *   - 부모 타입으로 자식 클래스를 참조
 *     - 상속시켜 준 멤버만 접근 가능
 *   - instanceof 연산자 : 실제 타입 확인
 * 
 * - 자동 형변환 up-casting		Parent = Child
 *   - 생략가능
 *   - 자식을 부모타입으로 변환
 *   
 * - 강제 형변환 down-casting	Child = (Child) Parent
 *   - 생략 불가
 *   - 부모를 자식타입으로 변환
 *   - 실행 오류 발생 가능 
 * 	
*/	
	
/* 추상화(abstraction) -----------------------------------
 * - 구체적인 개념으로부터 공통된 부분들만 추려내어 일반화
 *   - 일반적으로 사용할 수 있는 단계가 아닌 미완성적인 틀 개념
 *   - 클래스 및 메서드에 적용
 *   
 * 클래스의 추상화
 * - 상속 계층에서 추상적인 개념을 나타내기 위해 사용
 * - 의미적으로 유사한 클래스들을 묶을 때 사용
 *   - 공통으로 사용할 데이터 필드와 메서드 정의
 * - 클래스 선언 시 abstract 키워드 명시
 *   - 데이터 필드, 일반 메서드, 추상 메서드를 가질 수 있음
 *   - 인스턴스 생성 불가
 *     - 자식 클래스에서 상속을 받아 추상 메서드를 오버라이딩하여 구현
 *     
 * 메서드의 추상화
 * - 추상 클래스의 내부에 abstract 키워드로 선언
 *   - 미완성 상태
 * - 메서드의 구현부({ ... }) 정의 불가
 * - 접근제어자 반환타입 메서드이름([매개변수, ...]);
 * 
*/	
	
/* 인터페이스 (interface)
 * - 100% 추상 클래스
 * - abstract 키워드가 생략되어 있음
 * - 데이터는 상수만 선언 가능
 *   - public static final 생략 가능
 * - 객체 생성 불가
 *   - 자식 클래스에서 implements하여 구현
 * - 인터페이스 사이에는 다중 상속 가능
 * - interface 키워드를 이용하여 선언
 *   - 주로 형용사로 명명
*/	
	
/* 내부 클래스 nested class
 * - 클래스의 내부에 선언된 클래스
 * - 코드의 간략화 및 코드 관리 용이
 * 
 * - Member(인스턴스) inner class
 * - Static inner class
 * - Local inner class
 * - Anonymous inner class	
*/	
	
/* 예외(exception)
 * - 가벼운 오류
 * - 프로그램적으로 처리
 * - 복구 가능
 * 
 * 오류(error)
 * - 치명적 오류
 * - JVM에 의존하여 처리
 * - 더이상 실행 불가
 * 
 * 예외 발생
 * - 정수를 0으로 나누는 경우
 * - 배열의 index가 음수 또는 범위를 벗어나는 경우
 * - 부적절한 형변환 일어나는 경우
 * - 입출력을 위한 파일이 없는 경우
 * 
 * 예외 객체
 * - Exception 클래스 또는 하위 클래스
 * - 예외 발생 정보를 가지고 있으며
 *   예외 발생되는 경우 만들어지고 던져짐
 *   - throw new Exception();
 * - 예외 처리 코드가 있으면 계속 수행,
 *   없으면 메시지 출력 후 종료
 *   
 * checked exception
 * - 반드시 명시적 예외 처리 필요
 * - IOException, InterrunptedException 등
 * 
 * unchecked exception
 * - 잘못 작성된 코드로 인해 발생
 * - 명시적 예외 처리 불필요
 *   - 필요시 처리 가능
 * - RuntimeException 
 *   - ArithmeticException, NullpointerExcetion 등
 *   
 * 직접 예외 처리
 * - 던져진 예외 객체를 잡아서 처리
 * - try / catch 구문 try / catch / finally 구문 사용
 * 
 * 간접 에외 처리
 * - 메서드를 호출한 쪽으로 예외처리 위임
 * - 예외 발생 가능성이 있는 메서드 선언부의 매개변수 다음에
 *   throws 예외이름을 명시
 *   
 * 사용자 정의 예외 처리
 * - 직접 에외 클래스 작성 가능
 * - Exception 클래스를 상속받아 구현
 *   필요 시에 예외 객체를 직접 발생시킬 수 있음
 *   throw new 예외타입
 *   
 * try-with-resources
 * - 리소스 자동 관리
 * - try / catch 구문에서 사용되는 리소스 객체의 close() 자동 호출
 *   리소스를 자동으로 닫음
 * - java.lang.AutoCloseable 인터페이스 구현 클래스 대상
 */
}
